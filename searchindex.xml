<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>SQL复习</title><url>https://yeplain.xyz/post/sql-learning/</url><categories><category>sql</category></categories><tags><tag>sql</tag></tags><content type="html"> 学习笔记~
数据库完整性 实体完整性 主码必须唯一
参照完整性 外码必须与参照表中的一致
用户自定义完整性 用户自定义的约束
规范化 关系也是一个二维表，每行对应一个元组，每列对应一个域，每列称为属性
若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码（Candidate key）
若一个关系有多个候选码，则选定其中一个或多个为主码（Primary key）
候选码的多个属性称为主属性（Prime attribute），不包含在任何候选码中的属性称为非主属性
完全函数依赖和部分函数依赖
一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化
1NF 如果一关系模式r(R)的每个属性对应的域值都是不可分的(即原子的)，则称r(R)属于第一范式，记为r(R)Î1NF.
第一范式的目标是：将基本数据划分成称为实体集或表的逻辑单元，当设计好每个实体后，需要为其指定主码。
第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库
2NF 若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于任何一个候选码，则R∈2NF。
第二范式的目标：将只部分依赖于候选码（即依赖于候选码的部分属性）的非主属性移到其他表中。
S-L-C这个函数依赖图中非主属性Sdept和Sloc部分函数依赖于码(Sno, Cno)
将其分为两个表后使得非主属性对其各自的码都是完全函数依赖
2NF范式虽然消除了由于非主属性对候选码的部分依赖所引起的冗余及各种异常，但并没有排除传递依赖。因此，还需要对其进一步规范化
3NF 若R∈3NF，则每一个非主属性既不部分依赖于码也不传递依赖于码
第三范式的目标：去掉表中不直接依赖于候选码的非主属性
Sno→Sdept Sdept → Sno Sdept→Sloc 可得： Sno→Sloc，即S-L中存在非主属性对码的传递函数依 赖，S-L ∉ 3NF
采用投影分解法，把S-L分解为两个关系模式，以消除传递函数依赖：
BCNF 通常认为BCNF是修正的第三范式，有时也称为扩充的第三范式。
一个满足BCNF的关系模式有：
所有非主属性都完全函数依赖于每个候选码 所有的主属性都完全函数依赖于每个不包含它的候选码 没有任何属性完全函数依赖于非码的任何一组属性 BCNF范式排除了：
任何属性(包括主属性和非主属性)对候选码的部分依赖和传递依赖； 主属性之间的传递依赖。 例子：
关系模式STJ(S,T,J)中，S表示学生，T表示教师，J表示课程。每一教师只教一门课，
每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。
由语义可得到函数依赖：(S,J)→T；(S,T)→J；T→J
因为没有任何非主属性对码传递依赖或部分依赖，
STJ ∈ 3NF。
因为T是决定因素，而T不包含码，所以STJ 不属于 BCNF 关系。
候选码可以有多个，如上面（S,J）和（S,T）都是候选码，包含在任一一个候选码中的属性称为主属性，那么S,J,T都是主属性,以上不满足“所有的主属性都完全函数依赖于每个不包含它的候选码”
总结：</content></entry><entry><title>Golang三色标记+GC混合写屏障机制</title><url>https://yeplain.xyz/post/golang_gc/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag><tag>GC</tag></tags><content type="html">
Go语言的GC是一个值得探讨深究的问题，从V1.3的标记清除法到V1.5的三色标记法，再到V1.8并沿用至今的三色标记法+混合写屏障机制，它的发展过程十分有趣。那么具体是怎样实现的呢？一起和野生菌来看看吧~
Go v1.3 之前的标记清除法（mark and weep） GC ：Garbage Collection 垃圾回收
STW ：Stop the world &mdash;&ndash;>目的：减小这个时间
标记清除法流程 暂停程序业务逻辑，找出可达对象和不可达对象 开始标记，程序找出所有可达对象，并做上标记 标记完后，开始清除未标记的对象 停止暂停，程序继续运行，循环重复这个过程直到进程生命周期结束 标记清除法缺点 STW ：让程序暂停，程序出现卡顿（主要问题）
标记需要扫描整个heap
清除数据会产生heap碎片
解决办法 原有：
方法一：那么我们考虑将3、4互换位置？
先停止 再清除，使清除异步，减小STW的时间范围
但是标记的时间仍然很长
方法二： 尝试采用新的标记模式来替代标记清除法
即三色标记法
Go v1.5 三色标记法 三色标记法流程 三色标记法中，我们在GC中统计3个集合：白色标记表、灰色标记表、黑色标记表
程序起初创建，全部标记为白色，将所有对象放入白色集合中 这里我们将程序的根节点集合展开的形式
遍历Root Set(非递归形式，只遍历一次)，得到灰色节点 遍历灰色标记表，将可达的对象从白色标记为灰色；遍历后的灰色标记为黑色 重复上一步，直到灰色标记表中无任何对象
收集所有白色对象（垃圾）
循环多次，逐层将垃圾清除
三色标记如果不使用STW会存在问题吗？ 答案是会的，举一个例子：
此时对象1、4已遍历标记完成，2、7已加入灰色标记表中
可以看出，已经标记为灰色的对象2，有指针p指向白的的对象3
现在还没有扫描对象2
但这时，由于无STW的保护，可能并发会有黑色对象4引用到了对象3，即q指针指向了对象3
与此同时，对象2将指针p移除，这样对象3就被挂在了已经扫描完成的黑色对象4下
再继续正常执行算法逻辑，对象2、7标记为黑色，而对象3因为对象4已经不会再扫描了，被当作垃圾回收清除了
这是就发生了三色标记法最不希望发生的事，总结来说就是两个被同时满足的条件：
条件1. 一个白色对象被黑色对象引用
条件2. 灰色对象不再引用这个白色对象
这时就发生了对象丢失的现象！
那么怎么解决呢？很直接的方式就是继续利用我们之前的STW，但是它浪费了很多资源，对用户程序有很大的影响
那么如何在保证对象不丢失的情况下尽可能的提高GC效率，减少STW时间呢？
这就需要提出强弱三色不变式了
强弱三色不变式 强三色不变式 强制性的不允许黑色对象引用白色对象（破坏条件1）
弱三色不变式 黑色对象可以引用白色，但白色对象存在其他灰色对象对它引用，或者可达它的链路上游存在灰色（破坏条件2）
所以可以看出，只要满足强/弱之一，即可保证对象不丢失
那么如何实现呢？这里就用到了屏障机制
屏障机制 屏障：就是加入额外的判断机制，不打扰正常的业务
插入写屏障 对象被引用时，触发的机制
具体操作 在黑色A对象引用B对象时，B对象被标记为灰色（满足强三色不变式）
为了不影响性能，不在栈上使用
这里，对象8，9是黑色对象新引用的对象，但只将8标记为了灰色，对象9仍然是白色
在准备回收白色前，重新遍历扫描一次栈空间，此时加STW暂停保护栈，防止有新的白色被黑色引用
不足 结束时需要STW重新扫描栈，大约消耗10-100ms
删除写屏障 对象被删除时，触发的机制
具体操作 被删除的对象，如果自身为灰色或白色，那么被标记为灰色（满足弱三色不变式）
但可能出现问题，如图中对象5未被删除
不足 回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以存活过这一轮，在下一轮GC中被清理掉
Go v1.8混合写屏障机制 之前我们可以看到插入写屏障和删除写屏障都有一些不足
因此提出了混合写屏障机制
满足：变形的弱三色不变式
流程 GC开始将栈上的对象全部扫描并标记为黑色（之后不再进行二次扫描，无需STW） GC期间，任何在栈上创建的新对象，均为黑色 被删除的对象标记为灰色 被添加的对象标记为灰色 真实场景 场景一：对象被一个堆对象删除引用，成为另一个栈对象的下游
场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游
场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游
场景四：对象被一个栈对象删除引用，成为另一个堆对象的下游</content></entry><entry><title>k8s中grpc负载不均衡的问题探究</title><url>https://yeplain.xyz/post/grpc-http2/</url><categories><category>K8s</category></categories><tags><tag>grpc</tag><tag>HTTP2</tag><tag>k8s</tag></tags><content type="html">
在实习期间，公司流量平台的服务是基于gRPC微服务框架的，但是在使用K8s进行配置时，却发现出现了负载均衡失效的问题，那么是什么原因导致的，又该如何解决呢？一起和野生菌探究吧~
1. gRPC gRPC是由google开发的，是一款语言中立、平台中立、开源的RPC(Remote Procedure Call，远程过程调用)框架。
在gRPC里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC框架类似，gRPC也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。 特性 基于HTTP/2 HTTP/2 提供了连接多路复用、双向流、服务器推送、请求优先级、首部压缩等机制。可以节省带宽、降低TCP链接次数、节省CPU，帮助移动设备延长电池寿命等。gRPC 的协议设计上使用了HTTP2 现有的语义，请求和响应的数据使用HTTP Body 发送，其他的控制信息则用Header 表示。
IDL使用ProtoBuf gRPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议（类似于XML、JSON、hessian）。ProtoBuf能够将数据进行序列化，并广泛应用在数据存储、通信协议等方面。压缩和传输效率高，语法简单，表达力强。
多语言支持 gRPC支持多种语言，并能够基于语言自动生成客户端和服务端功能库。目前已提供了C版本grpc、Java版本grpc-java 和 Go版本grpc-go，其它语言的版本正在积极开发中，其中，grpc支持C、C++、Node.js、Python、Ruby、Objective-C、PHP和C#等语言，grpc-java已经支持Android开发。
2. HTTP2.0 HTTP/2，也就是超文本传输协议第2版，不论是1还是2，HTTP的基本语义是不变的，比如方法语义（GET/PUST/PUT/DELETE），状态码（200/404/500等），Range Request，Cacheing，Authentication、URL路径， 不同的主要是下面几点：
多路复用 在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」。 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。 二进制帧 HTTP/2 传输的数据是二进制的。相比 HTTP/1.1 的纯文本数据，二进制数据一个显而易见的好处是：更小的传输体积。这就意味着更低的负载。二进制的帧也更易于解析而且不易出错，纯文本帧在解析的时候还要考虑处理空格、大小写、空行和换行等问题，而二进制帧就不存在这个问题。
头部压缩 HTTP是无状态协议。简而言之，这意味着每个请求必须要携带服务器需要的所有细节，而不是让服务器保存住之前请求的元数据。因为http2没有改变这个范式，所以它也需要这样（携带所有细节），因此 HTTP 请求的头部需要包含用于标识身份的数据比如 cookies，而这些数据的量也在随着时间增长。每一个请求的头部都包含这些大量的重复数据，无疑是一种很大的负担。对请求头部进行压缩，将会大大减轻这种负担，尤其对移动端来说，性能提高非常明显。
HTTP/2 使用的压缩方式是 HPACK。
HTTP2.0在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用键-值对（用户代理、可接受的媒体类型，等等）只需发送一次。
事实上,如果请求中不包含首部（例如对同一资源的轮询请求），那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。
如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP2.0的连接存续期内始终存在,由客户端和服务器共同渐进地更新。
添加请求优先级 为了方便流的传输顺序，每个流都有权重和依赖。每个流的权重值在1~256之间，每个流可以详细给出对其他流的依赖。权重和依赖的结合可以使客户端构建出优先级二叉树的形式，来表达出更想依次得到哪些响应，然后服务端可以按权重分配硬件资源。
服务器推送 服务端可以为每个客户端请求发送多个响应，也就是说，除了原始的响应，服务端还可以给客户端发送额外的资源。服务器推送的资源可以由客户端缓存，推送的资源可以在不同的页面上重复使用，推送的资源可以与其他资源一起复用，推送的资源可以由服务器决定优先级，推送的资源也可以被客户端拒绝。
3. 长连接与短连接 HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。
短连接 HTTP1.0默认是短连接：也就是说每次与服务器交互，都需要新开一个连接。 连接->传输数据->关闭连接 比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 因为连接后接收了数据就断开了，所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。
长连接 连接->传输数据->保持连接 -> 传输数据-> …->直到一方关闭连接，多是客户端关闭连接。 长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
在HTTP1.1中默认就使用持久化连接来解决：建立一次连接，多次请求均由这个连接完成。 HTTP2所有性能增强的核心在于新的二进制分帧层(不再以文本格式来传输了)，它定义了如何封装http消息并在客户端与服务器之间传输。HTTP2连接上传输的每个帧都关联到一个“流”。流是一个独立的，双向的帧序列可以通过一个HTTP2的连接在服务端与客户端之间不断的交换数据。
什么时候用长连接，短连接？ 1、长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手， 这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都 不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果 用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。
2、像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网 站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成 千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连接好。
4. k8s中gRPC负载均衡失效 Kubernetes 的默认负载平衡通常不能与 gRPC 一起使用，在不使用 LoadBalance service 的情况下，因为 HTTP/2 链接复用特性，导致客户端的所有请求都发往同一个 Pod，导致负载不均衡。
原因可见gRPC Load Balancing on Kubernetes without Tears
首先，让我们了解为什么我们需要为 gRPC 做一些特别的事情。
gRPC 是应用程序开发人员越来越普遍的选择。与 JSON-over-HTTP 等替代协议相比，gRPC 可以提供一些显着的好处，包括显着降低（反）序列化成本、自动类型检查、形式化 API 和更少的 TCP 管理开销。
但是，gRPC 也打破了标准的连接级负载平衡，包括 Kubernetes 提供的负载平衡。这是因为 gRPC 是建立在 HTTP/2 之上的，而 HTTP/2 旨在拥有一个TCP长连接，所有请求都通过该连接进行多路复用——这意味着多个请求可以在任何时间点在同一个连接上处于活动状态。通常，这很好，因为它减少了连接管理的开销。但是，这也意味着（如您所想）连接级别的平衡不是很有用。一旦建立连接，就无需再进行平衡了。所有请求都将固定到单个目标 pod，如下所示： 那么为什么对于HTTP/1.1没有影响呢？ HTTP/1.1 也有长连接的概念，之所以在 HTTP/1.1中没有出现这个问题，是因为 HTTP/1.1 有几个特性自然会导致 TCP 连接循环。正因为如此，连接级别的平衡“足够好”，对于大多数 HTTP/1.1 应用程序，我们不需要做更多的事情。
要了解原因，让我们更深入地了解 HTTP/1.1。与 HTTP/2 相比，HTTP/1.1 不能多路复用请求。每个 TCP 连接一次只能激活一个 HTTP 请求。客户端发出请求，例如GET /foo，然后等待服务器响应。当请求-响应周期发生时，不能在该连接上发出其他请求。
通常，我们希望大量请求并行发生。因此，为了有并发的 HTTP/1.1 请求，我们需要建立多个 HTTP/1.1 连接，并在所有这些连接上发出我们的请求。此外，长期 HTTP/1.1 连接通常会在一段时间后过期，并被客户端（或服务器）断开。这两个因素结合在一起意味着 HTTP/1.1 请求通常会在多个 TCP 连接之间循环，因此连接级别的平衡是有效的。
所以我们怎样实现gRPC的负载均衡(load balance)呢？ 现在回到 gRPC。由于我们无法在连接层面进行均衡，所以为了做 gRPC 负载均衡，我们需要从连接均衡转向request均衡。换句话说，我们需要为每个目标打开一个 HTTP/2 连接，并在这些连接之间平衡request，如下所示： 在网络方面，这意味着我们需要在 L5/L7 而不是 L3/L4 做出决策，即我们需要了解通过 TCP 连接发送的协议。
我们如何做到这一点？有几个选择。首先，我们的应用程序代码可以手动维护自己的目标负载平衡池，我们可以配置我们的 gRPC 客户端以使用这个负载平衡池。这种方法为我们提供了最大的控制权，但它在 Kubernetes 等环境中可能非常复杂，在 Kubernetes 重新调度 Pod 时，池会随着时间而变化。我们的应用程序必须观察 Kubernetes API 并与 Pod 保持同步。
或者，使用如下两种方法：
代理负载平衡 在代理负载均衡中，客户端将rpc发送给LB (load Balancer)代理。LB将RPC调用分发到一个可用的后端服务器，该后端服务器实现为调用提供服务的实际逻辑。LB跟踪每个后端的负载，并实现公平分配负载的算法。客户端本身并不知道后台服务器。客户端是不可信的。这种体系结构通常用于面向用户的服务，其中来自开放互联网的客户端可以连接到服务器。
客户端负载均衡 在客户端负载平衡中，客户端知道许多后端服务器，并为每个RPC选择一个后端服务器。如果客户端希望实现基于服务器负载报告的负载均衡算法。对于简单的部署，客户机可以在可用的服务器之间轮询请求。
我们考虑使用 gRPC client LB 配合 Headless Service
使用gRPC client LB 配合 Headless Service在 Kubernetes 上实现 gRPC 负载平衡 ···· 未完待续····</content></entry><entry><title>高危端口及解决方案</title><url>https://yeplain.xyz/post/port/</url><categories><category>cybersecurity</category></categories><tags><tag>port</tag><tag>cybersecurity</tag></tags><content type="html"> 介绍135、139、445三个高危端口，以及它们的关闭和开启方式。
135端口 端口介绍 在 Windows 默认的五个典型开放端口中，135 用途最为复杂，也最容易引起外部攻击。主要用于使用RPC（远程过程调用）协议并提供DCOM（分布式组件对象模型）服务。
通过RPC可以保证在一台计算机上运行的程序可以顺利地执行远程计算机上的代码：具体来说，会向对方电脑的 135 端口询问可以使用哪个端口进行通信。这样，对方的电脑就会告知可以使用的端口号。使用DCOM可以通过网络直接进行通信，能够包括HTTP协议在内的多种网络传输。
端口漏洞 Windows 2000和Windows XP⽤户曾中的“冲击波”病毒就是利⽤RPC漏洞进行攻击。RPC本⾝在处理通过TCP/IP的消息交换部分有⼀个漏洞，该漏洞是由于错误地处理格式不正确的消息造成的。该漏洞会影响到RPC与DCOM之间的⼀个接⼝，该接⼝侦听的端⼝就是135。
操作建议 为了避免“冲击波”病毒的攻击，建议关闭该端⼝。
关闭方法 单击 “开始”-“运行”，输入 “dcomcnfg”，单击 “确定”，打开组件服务。 在弹出的 “组件服务” 对话框中，选择 “计算机” 选项。 在 “计算机” 选项右边，右键单击 “我的电脑”，选择 “属性”。 在出现的 “我的电脑属性” 对话框 “默认属性” 选项卡中，去掉 “在此计算机上启用分布式 COM” 前的勾。 选择 “默认协议” 选项卡，选中 “面向连接的 TCP/IP”，单击 “移除” 按钮。 单击 “确定” 按钮，设置完成，重新启动后即可关闭 135 端口。 开启方法 单击 “开始”-“运行”，输入 “dcomcnfg”，单击 “确定”，打开组件服务。 在弹出的 “组件服务” 对话框中，选择 “计算机” 选项。 在 “计算机” 选项右边，右键单击 “我的电脑”，选择 “属性”。 在出现的 “我的电脑属性” 对话框 “默认属性” 选项卡中，选中 “在此计算机上启用分布式 COM” 前的勾。 选择 “默认协议” 选项卡，单击“添加”按钮，选中 “面向连接的 TCP/IP”。 单击 “确定” 按钮，设置完成，重新启动后即可打开 135 端口。 139端口 端口介绍 139端口用于NBT协议（即Net Bios Over TCP/IP），其属于SMB（Server Message Block）Windows协议族。NBT使用137（UDP）、138（UDP）和139（TCP）来实现基于TCP/IP的NETBIOS网际互联。而139端口的作用就是获得NETBIOS/SMB服务（即NetBIOS File and Print Sharing协议），这个协议被用于Windows文件和打印机共享。
具体来说，SMB协议根据 DNS 服务器中的名字列表信息，寻找需要通信的对象。如果顺利地得到对象的 IP 地址，就可以访问共享资源 。Windows 2000 以前版本的 Windows 使用 NetBIOS 协议解决各计算机名的问题。通过向 WINS 服务器发送通信对象的 NetBIOS 名，取得 IP 地址。
在 SMB 通信中，首先要取得通信对象的 IP 地址，然后向通信对象发出开始通信的请求。如果对方充许进行通信，就会确立会话层(Session)。并使用它向对方发送用户名和密码信息，进行认证。如果认证成功，就可以访问对方的共享文件。在这些一连串的通信中使用的就是 139 端口。
端口漏洞 在默认设置下，Windows 会开放提供文件共享服务的 TCP 139 号端口。一旦文件共享服务启动，系统就会进入等待状态。而共享资源则可以利用 net 命令轻松地进行分配。尽管 C 盘如果没有管理员权限就无法共享，但如果不经意地将 Guest 帐号设置为有效以后，攻击者就能够访问 C 盘，非常轻松地破坏硬盘。 2017年10月，由于病毒“坏兔子”来袭，国家互联网应急中心等安全机构建议用户及时关闭计算机以及网络设备上的445和139端口。
操作建议 在因特网上公开的服务器打开 139 端口是一件非常危险的事情。如果有 Guest 帐号，而且没有设置任何密码时，就能够被人通过因特网轻松地盗看文件。如果给该帐号设置了写入权限，甚至可以轻松地篡改文件。也就是说在对外部公开的服务器中不应该打开这些端口。通过因特网使用文件服务器就等同自杀行为，因此一定要关闭 139 端口。
关闭方法 打开控制面板，选择“网络和Internet”。 在弹出的 “网络和Internet” 对话框中，单击 “网络和共享中心” 按钮。 在出现的 “网络和共享中心” 对话框中，选择左侧 “更改适配器设置”。 然后选中本地连接的网络，右键“属性”。 选择Internet协议版本4（TCP/IPv4）—>属性—>高级—>WINS—>禁用TCP/IP上的NetBIOS(S)。 单击 “确定” 按钮，设置完成，重新启动后即可关闭 135 端口。 开启方法 打开控制面板，选择“网络和Internet”。 在弹出的 “网络和Internet” 对话框中，单击 “网络和共享中心” 按钮。 在出现的 “网络和共享中心” 对话框中，选择左侧 “更改适配器设置”。 然后选中本地连接的网络，右键“属性”。 选择Internet协议版本4（TCP/IPv4）—>属性—>高级—>WINS—>启用TCP/IP上的NetBIOS(S)。 单击 “确定” 按钮，设置完成，重新启动后即可打开 135 端口。 445端口 端口介绍 445 端口是一种TCP端口，该端口在windows 2000 Server或Windows Server 2003系统中发挥的作用与139 端口是完全相同的。具体地说，它可以提供局域网中文件或打印机共享服务。不过该端口是基于CIFS协议（通用因特网文件系统协议）工作的，而139 端口是基于SMB协议（服务器协议族）对外提供共享服务。同样地，攻击者与445 端口建立请求连接，也能获得指定局域网内的各种共享信息。
445 端口的作用是实现一些共享文件夹以及一些共享打印机的访问工作，只要在局域网络的范围之内就能进行轻松的访问工作。
端口漏洞 由于只要在局域网络的范围之内就能通过445 端口进行访问，所以黑客侵入的可能性很高，黑客可以通过445端口进入我们的硬盘，从而对我们的文件进行共享，或者将我们硬盘内的数据格式化，导致我们的数据丢失。 2017年10月，由于病毒“坏兔子”来袭，国家互联网应急中心等安全机构建议用户及时关闭计算机以及网络设备上的445和139端口。多家网络安全机构监测分析发现，与此前席卷多国的WannaCry、Petya勒索病毒类似，这次在集团范围内传播的“蠕虫”病毒也会以感染的设备为跳板，攻击局域网内的其他电脑，形成“一台中招，一片遭殃”的情况。
操作建议 与139 端口类似，公开服务器 445 端口是一件非常危险的事情。容易被黑客通过因特网轻松地盗看文件。如果给该帐号设置了写入权限，甚至可以轻松地篡改文件。也就是说在对外部公开的服务器中不应该打开这些端口。通过因特网使用文件服务器就等同自杀行为，因此建议关闭445 端口。
关闭方法 单击 “开始”-“运行”，输入 “regedit”，单击 “确定” 按钮，打开注册表。 找到注册表项 “HKEY_LOCAL_MACHINE\System\Controlset\Services\NetBT\Parameters”。 选择 “Parameters” 项，右键单击，选择 “新建”——“DWORD 值”。 将 DWORD 值命名为 “SMBDeviceEnabled”。 右键单击 “SMBDeviceEnabled” 值，选择 “修改”。 在出现的 “编辑 DWORD 值” 对话框中，在 “数值数据” 下，输入 “0”，单击 “确定” 按钮，完成设置。 开启方法 单击 “开始”-“运行”，输入 “regedit”，单击 “确定” 按钮，打开注册表。 找到注册表项 “HKEY_LOCAL_MACHINE\System\Controlset\Services\NetBT\Parameters”。 选择 “Parameters” 项。 在右侧右键选中删除“SMBDeviceEnabled”值。 单击 “是” 按钮，设置完成，重新启动后即可打开 135 端口。</content></entry><entry><title>wsl2更新源失败问题</title><url>https://yeplain.xyz/post/wsl2/</url><categories><category>Linux</category></categories><tags><tag>wls</tag><tag>Linux</tag></tags><content type="html">
在使用wsl2时，由于其内部环境无法使用外部代理，因此需要更换源来加快下载或更新速度，但是换了多个源都出现了失败的问题，最后终于成功解决了，记录一下。
一般都会推荐使用国内的镜像源，比如163或者阿里云的镜像服务器
但是执行sudo apt-get update仍然报错，问题在于DNS没有配置好。 解决方法：
sudo vi /etc/resolv.conf
添加
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTENnameserver 127.0.1.1#这里用的是阿里云的DNS服务器nameserver 223.5.5.5 nameserver 223.6.6.6</content></entry><entry><title>Redis持久化实现方式</title><url>https://yeplain.xyz/post/redis-persist/</url><categories><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html">
怎么样批量实现Redis中key的持久化？一起来看看吧~
方法一 编写shell脚本：使用管道
redis-cli -h 127.0.0.1 -p 6379 keys "white:*" | xargs -i redis-cli -h 127.0.0.1 -p 6379 expire {} 86400 redis-cli keys "white:*" | xargs -i redis-cli expire {} 86400 redis-cli -h 127.0.0.1 -p 6379 keys "white:*" | xargs redis-cli -h 127.0.0.1 -p 6379 del 方法二 用Go写了一个脚本，buid为linux上的二进制文件后执行：
package main import ( "fmt" "github.com/garyburd/redigo/redis" ) func main() { conn, err := redis.Dial("tcp", "127.0.0.1:6379") if err != nil { fmt.Println("Connect redis failed,", err) return } defer conn.Close() persist("rls:*", conn) persist("white:*", conn) persist("black:*", conn) persist("grey:*", conn) persist("breach:white*", conn) persist("breach:black*", conn) } func persist(Key string, conn redis.Conn) { scan, err := conn.Do("Scan", "0", "match", Key, "count", 2000000) if err != nil { fmt.Println("connect redis failed,", err) return } dataList := scan.([]interface{})[1].([]interface{}) for _, item := range dataList { itemStr := string(item.([]uint8)) _, err = conn.Do("PERSIST", itemStr) if err != nil { fmt.Println(err) return } } fmt.Printf("%s PERSIST done!\n", Key) return }</content></entry><entry><title>Redis与Mysql一致性实现探究</title><url>https://yeplain.xyz/post/redis-mysql/</url><categories><category>Redis</category></categories><tags><tag>Redis</tag><tag>Mysql</tag></tags><content type="html">
在实习的项目开发中，遇到了一个问题，就是流量平台的数据都存储在数据库中，缓存会存一部分，但由于有TTL，会定期删除，因此如何保证Redis和Mysql中的数据一致性是个亟待解决的问题。一起来看看吧~
具体来说：
如果只是将redis的TTL=-1，可能会导致问题： a. 缓存利用率低：不经常访问的数据，还一直留在缓存中
b. 数据不一致：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）
并发中，我们考虑同步对二者内部的数据进行修改，有两种方案： ​ a. 先更新缓存，后更新数据库
​ b. 先更新数据库，后更新缓存
​ a的话，若后者失败，则前者失效后，再读则会重置旧值
​ b的话， 若后者失败，要一段时间后才会更新
并发的时候，会出现不一致的问题，添加分布式锁可以解决，但每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。
因此，使用删除缓存的解决办法： ​ a. 先删除缓存，后更新数据库
b. 先更新数据库，后删除缓存
a并发的时候，还是有不一致的情况发生; b由于更新数据库（写）的时间比读的时间长, 且会加锁，发生问题概率低
如果后者失败，则多次重试： 立即重试很大概率「还会失败」
「重试次数」设置多少才合理？
重试会一直「占用」这个线程资源，无法服务其它客户端请求
因此要异步重试：把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。
或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。
消息队列保证可靠性：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）
消息队列保证消息成功投递：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的需求）
如果确实不想在应用中去写消息队列，近几年比较流行的解决方案：订阅数据库变更日志，再操作缓存。 具体来讲就是业务应用在修改数据时，「只需」修改数据库，无需操作缓存。MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。
订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：
无需考虑写消息队列失败情况：只要写 MySQL 成功，Binlog 肯定会有
自动投递到下游队列：canal 自动把数据库变更日志「投递」给下游的消息队列
至此，我们可以得出结论，想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。
如果使用「先更新数据库，再删除缓存」方案，其实也发生不一致：
线程 A 更新主库 X = 2（原值 X = 1）
线程 A 删除缓存
线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）
从库「同步」完成（主从库 X = 2）
线程 B 将「旧值」写入缓存（X = 1）
最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。
缓存延迟双删策略： 线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。
双删的策略就是保证每次在数据修改的时候去吧redis 的数据删完 然后让它去查数据库</content></entry><entry><title>详解Redis缓存穿透、击穿、雪崩原理及解决方法</title><url>https://yeplain.xyz/post/my-first-post/</url><categories><category>Redis</category></categories><tags><tag>Redis</tag></tags><content type="html">
在实际的项目开发中，用户的数据我们一般都使用数据库进行存储，其数据是存储在磁盘上的，虽然稳定，但I/O速度很慢，当用户量很多且有并发需求时，请求数量一上来数据库就很容易崩溃。
为了解决这一问题，Redis这一内存数据库得到了广泛的应用，将其作为缓存中间件，可以将磁盘数据库中的数据缓存在Redis上，从而相当于在内存上进行了缓存，可以大大提高读写速度，提高系统性能。
然而在缓存中，由于Redis和Mysql这类磁盘数据库速度的不匹配，会出现缓存异常的问题，其中缓存穿透、缓存击穿、缓存雪崩是需要考虑并解决的问题。
缓存穿透 问题描述 Key对应的数据并不存在，每次请求访问key时，缓存中查找不到，请求都会直接访问到数据库中去，请求量超出数据库时，便会导致数据库崩溃。如一个用户id不存在，数据库与缓存都不存在该id，此时黑客便可以利用此漏洞不断访问该id，造成数据库崩溃。
解决方案 ①对空值缓存：如果一个查询数据为空（不管数据是否存在），都对该空结果进行缓存，其过期时间会设置非常短。
②设置可以访问名单：使用bitmaps类型定义一个可以访问名单，名单id作为bitmaps的偏移量，每次访问时与bitmaps中的id进行比较，如果访问id不在bitmaps中，则进行拦截，不给其访问。
③采用布隆过滤器：布隆过滤器可以判断元素是否存在集合中，他的优点是空间效率和查询时间都比一般算法快，缺点是有一定的误识别率和删除困难。
④进行实时监控：对于redis缓存中命中率急速下降时，迅速排查访问对象和访问数据，将其设置为黑名单。
缓存击穿 问题描述 key中对应数据存在，当key中对应的数据在缓存中过期，而此时又有大量请求访问该数据，缓存中过期了，请求会直接访问数据库并回设到缓存中，高并发访问数据库会导致数据库崩溃。
解决方案 ①预先设置热门数据：在redis高峰访问时期，提前设置热门数据到缓存中，或适当延长缓存中key过期时间。
②实时调整：实时监控哪些数据热门，实时调整key过期时间。
③对于热点key设置永不过期。
缓存雪崩 问题描述 key中对应数据存在，在某一时刻，缓存中大量key过期，而此时大量高并发请求访问，会直接访问后端数据库，导致数据库崩溃。 注意：缓存击穿是指一个key对应缓存数据过期，缓存雪崩是大部分key对应缓存数据过期
解决方案 ①构建多级缓存机制：nginx缓存+redis缓存+其他缓存。
②设置过期标志更新缓存：记录缓存数据是否过期，如果过期会触发另外一个线程去在后台更新实时key的缓存。
③将缓存可以时间分散：如在原有缓存时间基础上增加一个随机值，这个值可以在1-5分钟随机，这样过期时间重复率就会降低，防止大量key同时过期。
④使用锁或队列机制：使用锁或队列保证不会有大量线程一次性对数据库进行读写，从而避免大量并发请求访问数据库，该方法不适用于高并发情况。</content></entry><entry><title>Linux及shell相关指令学习笔记</title><url>https://yeplain.xyz/post/shell/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>Shell</tag></tags><content type="html">
Linux及Shell常用指令学习笔记~
Linux ctrl + alt + f1~f6 进入真正shell终端控制台
ctrl + alt + f7 图形化界面
ctrl + / ctl - 放大缩小
ls pwd
linux 只有一棵树
cd / 切换到根目录
根目录下的文件夹说明 /bin : 存放可以直接执行的常用命令 （链接到/usr/bin/)
/sbin : 管理员用的指令（链接到/usr/sbin/)
/lib : 库目录，放置动态链接库（链接到/usr/lib/)
/lib64 : 64位特殊的动态链接库（链接到/usr/lib64/)
/boot : 存放内核及启动所需要的文件
/dev : 设备目录
/etc : 系统需要的配置文件 .conf
/home : 普通用户的主目录
/root : 管理员用户的主目录
/opt : 放置其他第三方文件
/media ：挂载目录，识别U盘、光驱等外部设备
/mnt : 挂载目录，外部存储
/proc：进程目录
/run : 运行时的临时信息，重启后无
/srv : 系统服务
/sys : 系统硬件信息
/tmp : 系统临时目录
/usr : 用户相关的文件
/var : 放置log日志等文件
Vi/ Vim编辑器 vim 编辑器之神(小而精) emacs 神之编辑器(all in one)
切换输入法 win + 空格
vim ... vi ...
三种模式：
命令模式下： w //已写入 q //退出
一般模式 u //撤回 yy//复制一行 p//粘贴 5p//粘贴5行 8yy//复制了8行
dd //删除当前行 3dd //删除3行 dw //删除当前词 d$//删除当前光标后这一行的内容 d^ //删除当前光标前的内容
y$ //复制当前光标后这一行的内容 y^ //复制当前光标前的内容 yw//复制当前光标单词
x //光标所在位置之后一个个剪切 X//光标所在位置之前一个个剪切
r // 替换当前字符 R //替换一串字符，会依次替换
^ //移动到行头 $ //移动到行尾 w //移动到下一个词头
b //上一个词词头 e//移动到当前词尾
gg //文档开头 G//文档最后一行 3G //跳到第3行行头
命令模式下 set nu //显示行号 set nonu //关闭行号
编辑模式 命令模式 网络配置和系统管理操作 ifconfig //查看网络配置
ping //icmp
桥接模式 NAT模式
vim /etc/sysconfig/net/network-scripst/ifcfg-ens33
service network restart //重启网络服务
hostname //显示主机名
vim /etc/hostname //修改主机名
ssh root@主机名 //ssh远程登陆 Xshell为主要工具
系统管理 Linux服务管理 service 服务：启动后一直存在，常驻内存的进程
守护进程daemon = 系统服务
service 服务名 start | stop |restart |status
查看服务的方法：
ls /usr/lib/systemd/
新： systemctl status network
系统运行级别 setup设置自启动服务
开机 -> BIOS -> /boot ->init进程 -》运行级别 -》运行级别对应的服务
关机重启 shutdown
shutdown -c // 取消
shutdown now //立即关机
shutdown 3 //3min后关机
shutdown 15:28 // 定时关机
sync //将数据由内存同步到硬盘中
halt //停机，关闭系统，但不断电
poweroff //断电
reboot //重启 == shutdown -r now
经验： 先sync 再shutdown now
帮助命令 man ls
ctrl + l ->清屏
文件目录 基础 pwd //绝对路径
cd
cd ../ 返回上一层
cd - 返回上次的目录
ls
ls -a 所有 .开头的文件是隐藏文件
ls -l == ll
mkdir 创建目录
mkdir -p g/h/i 没有父目录就自动创建
rmdir 删除目录
touch a.txt 创建文件
cp source dest 复制文件到&hellip;
rm 删除文件
rm -f 强制删除
rm -r 递归删除
rm -rf 全部删除
rm -f ./* 删除当前目录下所有文件
mv source dest 移动文件
mv a.txt b.txt 重命名
cat 查看文件内容
cat -n 显示行号
more 按页显示文件内容 空格翻页 q退出
less 打开大的文件 b往前 /关键字 查询 q退出
echo 输出内容到控制台
echo -e 支持转义字符
####　输出重定向
ls -l > 文件 将列表内容写入文件(覆盖写)
ls -l &raquo; 文件 将列表内容追加写入文件末尾(追加写)
head -n 20 &hellip;txt 显示开头20行
tail -n 20 &hellip;txt 显示末尾20行
tail -f 文件 实时追踪文档所有更新
硬链接和软链接 Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。
硬连接
硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。
硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。
软连接
另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。
ln -s [原文件或目录] [软链接名] 在当前目录下给源文件创建一个软链接
相当于一个指针
pwd 显示该软链接的路径
pwd -P 显示所指的实际真正的物理路径
rm -rf myFolder 只是删除软链接
rm -rf myFolder/ 删除了真正的文件夹
ln [原文件或目录] [软链接名] 在当前目录下给源文件创建一个硬链接
通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效
此外,硬链接只能针对文件,不能针对目录; 而软链接既可以文件也可以目录
其他 history 显示历史输入过的命令
history -c 清除历史
时间日期 date 当前时间信息
date + %Y
date + %m
date + %d
date &ldquo;+%Y-%m-%d %H:%M:%S&rdquo;
date +%s 当前秒数对应的时间戳(1970年1月1日到当前的秒数)
date -s &ldquo;2017-06-19 20:42:33&rdquo; 设置系统时间
ntpdate 同步时间
cal 当前月历
用户权限 用户 useradd 用户名 添加用户
cd /home 除了root, 添加的用户都在/home下
passwd 用户名 设置密码
id 用户名 看用户是否存在
cat /etc/passwd 查看所有用户
su 用户名 切换用户
who am i 当前用户名称
sudo 为普通用户赋予root权限
userdel 删除用户
用户组 groupadd 组名 新增组
usermod -g 组名 用户名 新增用户到组
groupdel 组名 删除组
文件权限 ll 或 ls -l 显示文件权限
改变文件权限:
chmod [{ugoa}{+-=}{rwx}] 文件或目录 (u:所有者 g:所有组 o:其他人)
chmod [mode=421] [文件或目录]
r =4 w=2 x=1 mode=[0,7]
eg: chmod 777 a.txt chmod 644 b.txt
chown 更改属主 -R(对文件夹,递归所有文件)
chgrp 更改属组
搜索查找 find [搜索范围] [选项] 对象
选项有 -name -user -size
eg: find /root -name &ldquo;*.cfg&rdquo;
​ find /root -size +10M
locate 搜索文件 //基于数据库查询
可能不及时,所以要先 updatedb
which [命令]
eg: which ls which locate
grep过滤查找及"|&ldquo;管道符
管道符&rdquo;|", 表示将前一个命令的处理结果输出传递给后面的命令处理
grep 选项 查找内容 源文件 (选项 -n 显示匹配行及行号)
eg: ls | grep .cfg
wc 文件名 (输出:行数 词数 字节数)
eg: grep -n boot initial-setup-ks.cfg | wc
压缩解压 gzip/gunzip 只能压缩文件不能压缩目录; 不保留原来的文件; 同时多个文件会产生多个压缩包
zip /unzip 可以压缩文件夹
-d 指定压缩目录
tar [选项] &hellip;tar.gz 打包操作
-c 打包 -x解包 -z打包同时压缩
eg: tar -zcvf temp.tar.gz a.cfg b.txt 打包压缩
tar -zxvf temp.tar.gz -C /temp 解压
磁盘管理 tree ./ 当下所有的目录信息
du 所有目录\子文件夹等的大小(disk usage)
du -sh
df -h 查看当前磁盘空间
free -h 查看内存使用
lsblk 查看设备挂载情况
mount /umount 挂载/卸载
fdisk 分区
fdisk -l 查看磁盘分区详情
进程管理 前台显示的进程 后台常驻的进程(服务,守护进程)
ps 显示所有用户进程
ps aux ps -ef(可以看进程父子关系)
kill [选项] PID 终止进程
-9 强制关闭
killall 进程名 通杀
systemctl start [服务名] 又开启了服务
pstree 查看进程树
-p 显示pid
top 实时查看进程
-d 指定多少秒刷新 -p 指定查看某个进程 -i 不显示闲置\僵尸进程
ifconfig ping
netstat -anp | grep 进程号 查看该进程网络信息
netstat -nlp | grep 端口号 查看网络端口号占用情况
crontab 设置定时任务
crontab -l 查看已有定时任务
crontab -e 编辑定时任务
详情见 &hellip;&hellip;..
Shell 执行脚本 chmod +x ./test.sh
./test.sh
或者 sh hello.sh 或者 source hello.sh 或者 . hello.sh
区别: sh 或者bash 执行是开了一个子shell , 而source 和./ 是直接在当前shell执行
使用变量 env 查看全局环境变量
set 查看所有变量
your_name="yuanye"
echo $your_name
echo ${your_name}
readonly your_name //设定为只读变量
unset your_name //删除变量
g="hello, "$your_name" ! " //字符串拼接
echo ${#your_name} //获取字符串长度
echo ${your_name:1:2} //从第2个字符开始截取2个字符
echo `expr index "$your_name" a` //查找子字符的位置
# 注释
:&lt;&lt;EOF ····· EOF //多行注释
传递参数 echo &ldquo;Shell 传递参数实例！&rdquo;; echo &ldquo;执行的文件名：$0&rdquo;; echo &ldquo;第一个参数为：$1&rdquo;; echo &ldquo;第二个参数为：$2&rdquo;; echo &ldquo;第三个参数为：$3&rdquo;;
chmod +x test.sh ./test.sh 1 2 3 $# 变量数
$* 所有变量整体 $@ 所有变量形成一个数组
$? 最后一次的返回值
基本运算符 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。
例如，两个数相加 注意使用的是反引号 ` 而不是单引号 '：
val=`expr 2 + 2`
echo "两数之和为 ：$val"
echo $(()) 或者 $[] 更简便的写法
eg: b=$[2+2]
条件判断 test $a=Hello
echo $? 0为真 1为假
[ $a = hello] 中间有空格
echo $?
整数比较:
[ 2 -lt 5 ] -lt 小于 -gt 大于 -eq 等于 -le小于等于 -ge大于等于
文件判断:
[ -r hello.sh ] 看是否有什么权限 -r -w -x
[ -e /home/a.txt ] 看文件是否存在
多条件判断:
&amp;&amp; 前一条命令成功执行才执行后一条 || 前一条命令执行失败后才执行后一条
类似 &hellip;.. ? a : b 真执行a,假执行b
eg: [ 3 -lt 5 ] &amp;&amp; echo ok || echo notok
流程控制 if 判断 if [ 条件判断式 ]; then
程序
fi
等同于
if [ 条件判断式 ]
then
程序
fi
函数 系统函数 命令替换 eg: filename="$1"_log_$(date +%s)
basename /root/scipts/a.txt &mdash;> a.txt 去掉最后一个/前面的所有内容
dirname /root/scripts/a.txt &mdash;>/root/scripts 获取前面的路径部分
自定义函数 funname[]
{
​ Action;
​ [return int;]
}
正则表达式 模糊匹配
grep sed awk 都支持正则表达式
^ 匹配一行的开头
eg : grep ^a
$ 匹配一行的结束
eg : grep t$
. 匹配任意字符
eg: grep r..t 中间有两个字符
*出现任意次
eg: grep ro*t o出现任意多次 ,匹配root rot rooooot rt等等
以什么开头什么结尾:
grep ^a.*bash$ 以a开头,以bash结尾
字符区间 []
grep r[a,b]t 匹配rat,rbt
文本处理工具 cut cut [选项参数] filename
eg: cut -d " " -f 1 cut.txt
cat /etc/passed | grep bash$ | cut -d &ldquo;:&rdquo; -f 1,6,7
echo $PATH | cut -d &ldquo;:&rdquo; -f 2-
切割获取的ip地址:
ifconfig ens33 | grep netmask | cut -d " " -f 10
awk 把文件逐行的读入,已空格为默认分隔符将每行切片
awk [选项参数] &lsquo;/pattern1/ {action1} /pattern2/{action2}&hellip;&rsquo; filename
eg:搜索passwd文件已root关键字开头的所有行,并输出该行的第7列
cat /etc/passwd | grep ^root | cut -d &ldquo;:&rdquo; -f 7
cat /etc/passwd | awk -F &ldquo;:&rdquo; &lsquo;/ ^root/ print{$7}&rsquo;</content></entry><entry><title>从Protobuf到gRPC</title><url>https://yeplain.xyz/post/gprc-protobuf/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag><tag>grpc</tag></tags><content type="html">
Protobuf 是Protocol Buffers的简称，它是Google公司开发的一种数据描述语言，用于描述一种轻便高效的结构化数据存储格式，并于2008年对外开源。Protobuf可以用于结构化数据串行化，或者说序列化。它的设计非常适用于在网络通讯中的数据载体，很适合做数据存储或 RPC 数据交换格式，它序列化出来的数据量少再加上以 K-V 的方式来存储数据，对消息的版本兼容性非常强，可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。开发者可以通过Protobuf附带的工具生成代码并实现将结构化数据序列化的功能。一起和野生菌来看看吧~
protobuf 实际是一套类似Json或者XML的数据传输格式和规范，用于不同应用或进程之间进行通信时使用。通信时所传递的信息是通过Protobuf定义的message数据结构进行打包，然后编译成二进制的码流再进行传输或者存储。
具体实现方式为：
*.proto* –protoc, protoc-gen-go-> *.pb.go* :
protoc &ndash;go_out=output_directory input_directory/file.proto
( protoc &ndash;go_out=plugins=grpc:. ./hi.proto )
protoc是protobuf文件（.proto）的编译器，借助它可以把.proto文件转译成各种编程语言对应的源码。
protoc-gen-go插件可以产生go相关代码， 除上述序列化和反序列化代码之外， 还增加了一些通信公共库。它是protobuf编译插件系列中的Go版本
gRPC: 高性能，开源通用RPC框架。所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。</content></entry><entry><title>如何用Hugo搭建自己的个人博客(GithubPages + Aliyun)</title><url>https://yeplain.xyz/post/hugo-blog-make/</url><categories><category>blog</category></categories><tags><tag>hugo</tag><tag>github</tag><tag>blog</tag></tags><content type="html"> 个人博客有许多开源的框架，基于Go语言的Hugo框架有着快速方便的特点，且支持Markdown语法，利用它来构建博客可以大大提高我们的效率。下面一起来看看怎么基于它构建出我们理想的个人博客，并将它托管至GitHub上吧！
1. 安装Hugo 野生菌使用的是Windows系统，所以安装过程中会基于Windows进行讲解，有关其他操作系统的安装方法可以参考官方文档
首先去官网下载hugo框架，hugo官网
下载完成后检查是否安装成功，输入:hugo version，若出现版本信息则表示安装成功。 2. 新建站点 这时候我们已经安装好了hugo框架，接下来进入我们想要放置网站文件的文件夹中，输入hugo new site blog， 再进入新创建的路径下cd blog
野生菌恭喜你！已经创建了自己的博客啦~
3. 为博客设置主题 Hugo 中你可以自己构建博客的主题或者使用网上已经有的一些主题。前人栽树，后人乘凉，在hugo主题官网
中找一个自己喜欢的主题吧！ 然后进入主题所在的目录：cd themes 克隆主题：git clone https://themes.gohugo.io/themes/hugo-theme-next/,这里野生菌的主题是NexT
然后在themes文件夹下会出现如下目录： 之后按照主题对应的要求，配置相关的文件。 配置完成后，输入hugo server -D，在浏览器中输入http://localhost:1313，就可以在本地可视化你的博客啦！
4. 使用Github进行托管 这时候虽然博客雏形已经有了，但只能是在本地查看，为了让别人也能通过网址访问，我们可以使用GitHub来对我们的博客进行免费托管。
在 GitHub 上创建一个仓库，不过仓库名有特殊要求。如果是个人账号，比如野生菌的 GitHub ID 是 yeplain，则仓库名是：yeplain.github.io 之后在你的 Hugo 网站目录下键入命令hugo -v生成网站的相应文件，存储在 public 目录下。
进入public目录下，并按照正常的git命令操作： cd public git init git add . git commit -m "first commit" git remote add origin https://github.com/yeplain/yeplain.github.io.git #推送到远程git git push origin master
之后如果我们写了新的博客 在blog文件夹中执行hugo 然后cd public 依次执行 git init git add . git commit -m "new commit" git push -u origin master 就行啦~~~
5. 使用Aliyun域名进行托管 首先在阿里云上购买一个域名，我买的是yeplain.xyz
通过实名认证后，选择对应域名中的解析
添加两条类型为CNAME的记录，值指向你自己的github博客url，我的是yeplain.github.io
在github博客仓库的Settings页面里，将腾讯云购买的域名指定到Custom domain里
然后就可以了！</content></entry><entry><title>Leetcode Study</title><url>https://yeplain.xyz/post/leetcode/</url><categories><category>Golang</category></categories><tags><tag>Golang</tag></tags><content type="html"> Leetcode 刷题之旅~
1. 数组中重复的数字 描述 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1
数据范围：0≤n≤10000
进阶：时间复杂度O(n) ，空间复杂度O(n)
示例 输入： [2,3,1,0,2,5,3] 返回值：2 说明：2或3都是对的
代码 func duplicate( numbers []int ) int { // write code here m := make(map[int]bool,len(numbers)) for _, num := range numbers{ if m[num] { return num }else{ m[num] = true } } return -1 } 2. 二维数组中的查找 描述 在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[
[1,2,8,9], [2,4,9,12], [4,7,10,13], [6,8,11,15]
]
给定 target = 7，返回 true。
给定 target = 3，返回 false。
示例 代码</content></entry><entry><title>Markdown语法手册</title><url>https://yeplain.xyz/post/zh-markdown-syntax/</url><categories/><tags/><content type="html"> 本文提供了一个可以在 Hugo 内容文件中使用的基本Markdown语法示例，还展示了基本 HTML 元素在 Hugo 主题中是否使用 CSS 装饰。
标题 下面的 HTML 代码&lt;h1>—&lt;h6> 元素表示六个级别的节标题。 &lt;h1>是最高的节级别，&lt;h6>是最低的节级别。
H1 H2 H3 H4 H5 H6 段落 生活是什么？生活是柴米油盐的平淡；是行色匆匆早出晚归的奔波；生活是错的时间遇到对的人的遗憾；是爱的付出与回报；生活是看不同的风景，遇到不同的人；是行至水穷尽，坐看云起时的峰回路转；生活是灵魂经历伤痛后的微笑怒放；是挫折坎坷被晾晒后的坚强；生活是酸甜苦辣被岁月沉淀后的馨香；是经历风霜雪雨洗礼后的懂得；生活是走遍千山万水后，回眸一笑的洒脱。
有些事，猝不及防，不管你在不在乎；有些人，并非所想，不管你明不明白；有些路，必须得走，不管你愿不愿意。不怕事，不惹事，不避事，做好自己，用真心面对一切；少埋怨，少指责，少发火，学会沉静，用微笑考量一切；多体察，多包容，多思索，尽心尽力，虽缺憾但无悔。像蒲公英一样美丽，虽轻盈，但并不卑微，它有自己的生命，也有自己的世界！
引用 blockquote 元素表示从另一个来源引用的内容，可选的引用必须在 footer 或 cite元素内，也可选的内嵌更改，如注释和缩写。
引用没有归属 读懂自我，带着简单的心情，看复杂的人生，走坎坷的路！
注意： 可以在块引用中使用 Markdown 语法。
带归属的引用 不要通过分享记忆来交流，通过交流来分享记忆。
— 罗布·派克1
表格 表不是Markdown核心规范的一部分，但是Hugo支持开箱即用。
Name Age Bob 27 Alice 23 表格内使用Markdown语法 Italics Bold Code italics bold code 图像 ![图像描述](图像地址) 示例 常规用法 SVG图像 Google Chrome
Firefox Browser
小图标 点击图像可以打开图像浏览器，快试试吧。
代码块 带有引号的代码块 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 用四个空格缩进的代码块 &lt;!doctype html>
&lt;html lang="en">
&lt;head>
&lt;meta charset="utf-8">
&lt;title>Example HTML5 Document&lt;/title>
&lt;/head>
&lt;body>
&lt;p>Test&lt;/p>
&lt;/body>
&lt;/html>
代码块引用Hugo的内部高亮短代码 &lt;!doctype html> &lt;html lang="en"> &lt;head> &lt;meta charset="utf-8"> &lt;title>Example HTML5 Document&lt;/title> &lt;/head> &lt;body> &lt;p>Test&lt;/p> &lt;/body> &lt;/html> 列表类型 有序列表 First item Second item Third item 无序列表 List item Another item And another item 嵌套列表 Fruit Apple Orange Banana Dairy Milk Cheese 其他元素 — abbr, sub, sup, kbd, mark GIF 是位图图像格式。
H2O
Xn + Yn = Zn
按 CTRL+ALT+Delete 组合键结束会话。
大多数蝾螈在夜间活动，捕食昆虫、蠕虫和其他小动物。
以上引文摘自Rob Pike在2015年11月18日 Gopherfest 上的演讲
。&#160;&#8617;&#xfe0e;</content></entry><entry><title>富文本内容测试</title><url>https://yeplain.xyz/post/zh-rich-content/</url><categories/><tags/><content type="html"> Hugo 上有几个内置短码
，用于丰富内容，以及隐私配置
还有一组简单的短代码，支持各种社交媒体嵌入的静态和非 JS 版本。
YouTube 增强隐私短码 {{/&lt; youtube ZJthWmvUzzc >/}}
Twitter 短码 {{/&lt; twitter_simple 1085870671291310081 >/}}
Vimeo 短码 {{/&lt; vimeo_simple 48912912 >/}}
哔哩哔哩短码</content></entry><entry><title>图像占位符显示</title><url>https://yeplain.xyz/post/zh-placeholder-text/</url><categories/><tags/><content type="html"> 范德格拉夫原理（Van de Graaf Canon）重构了曾经用于书籍设计中将页面划分为舒适比例的方法。这一原理也被称为“秘密原理”，用于许多中世纪的手稿和古板书中。在范德格拉夫原理中，文本区域和页面的长款具有相同的比例，并且文本区域的高度等于页面宽度，通过划分页面得到九分之一的订口边距和九分之二的切口边距，以及与页面长宽相同的比例的文本区域。
Vagus 示例 The Van de Graaf Canon
总结 当然设计中的黄金比例是为人所熟知的，黄金分割的公式为a:b=b:(a+b)。这是指较小的两个矩形与较大的两个矩形以相同的组合方式相关联。黄金分割比例为1:1.618。</content></entry><entry><title>数据公式设置显示</title><url>https://yeplain.xyz/post/zh-math-typesetting/</url><categories/><tags/><content type="html"> Hugo 项目中的数学表示法可以通过使用第三方 JavaScript 库来实现。
在这个例子中，我们将使用 MathJax
创建一个文件 /content/en[zh-CN]/math.md
可以全局启用MathJax，请在项目配置中将参数math设置为true
或是在每页基础上启用MathJax，在内容文件中包括参数math: true
注意： 使用支持的TeX功能
的联机参考资料
例子 重复的分数 $$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} \equiv 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\cdots} } } } $$
总和记号 $$ \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right) $$
几何级数之和 我把接下来的两个例子分成了几行，这样它在手机上表现得更好。这就是为什么它们包含 \displaystyle。
$$ \displaystyle\sum_{i=1}^{k+1}i $$
$$ \displaystyle= \left(\sum_{i=1}^{k}i\right) +(k+1) $$
$$ \displaystyle= \frac{k(k+1)}{2}+k+1 $$
$$ \displaystyle= \frac{k(k+1)+2(k+1)}{2} $$
$$ \displaystyle= \frac{(k+1)(k+2)}{2} $$
$$ \displaystyle= \frac{(k+1)((k+1)+1)}{2} $$
乘记号 $$ \displaystyle 1 + \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots = \displaystyle \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \displaystyle\text{ for }\lvert q\rvert &lt; 1. $$
随文数式 这是一些线性数学: $$ k_{n+1} = n^2 + k_n^2 - k_{n-1} $$ ， 然后是更多的文本。
希腊字母 $$ \Gamma\ \Delta\ \Theta\ \Lambda\ \Xi\ \Pi\ \Sigma\ \Upsilon\ \Phi\ \Psi\ \Omega \alpha\ \beta\ \gamma\ \delta\ \epsilon\ \zeta\ \eta\ \theta\ \iota\ \kappa\ \lambda\ \mu\ \nu\ \xi \ \omicron\ \pi\ \rho\ \sigma\ \tau\ \upsilon\ \phi\ \chi\ \psi\ \omega\ \varepsilon\ \vartheta\ \varpi\ \varrho\ \varsigma\ \varphi $$
箭头 $$ \gets\ \to\ \leftarrow\ \rightarrow\ \uparrow\ \Uparrow\ \downarrow\ \Downarrow\ \updownarrow\ \Updownarrow $$
$$ \Leftarrow\ \Rightarrow\ \leftrightarrow\ \Leftrightarrow\ \mapsto\ \hookleftarrow \leftharpoonup\ \leftharpoondown\ \rightleftharpoons\ \longleftarrow\ \Longleftarrow\ \longrightarrow $$
$$ \Longrightarrow\ \longleftrightarrow\ \Longleftrightarrow\ \longmapsto\ \hookrightarrow\ \rightharpoonup $$
$$ \rightharpoondown\ \leadsto\ \nearrow\ \searrow\ \swarrow\ \nwarrow $$
符号 $$ \surd\ \barwedge\ \veebar\ \odot\ \oplus\ \otimes\ \oslash\ \circledcirc\ \boxdot\ \bigtriangleup $$
$$ \bigtriangledown\ \dagger\ \diamond\ \star\ \triangleleft\ \triangleright\ \angle\ \infty\ \prime\ \triangle $$
微积分学 $$ \int u \frac{dv}{dx},dx=uv-\int \frac{du}{dx}v,dx $$
$$ f(x) = \int_{-\infty}^\infty \hat f(\xi),e^{2 \pi i \xi x} $$
$$ \oint \vec{F} \cdot d\vec{s}=0 $$
洛伦茨方程 $$ \begin{aligned} \dot{x} &amp; = \sigma(y-x) \ \dot{y} &amp; = \rho x - y - xz \ \dot{z} &amp; = -\beta z + xy \end{aligned} $$
交叉乘积 这在KaTeX中是可行的，但在这种环境中馏分的分离不是很好。
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
这里有一个解决方案:使用“mfrac”类(在MathJax情况下没有区别)的额外类使分数更小:
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
强调 $$ \hat{x}\ \vec{x}\ \ddot{x} $$
有弹性的括号 $$ \left(\frac{x^2}{y^3}\right) $$
评估范围 $$ \left.\frac{x^3}{3}\right|_0^1 $$
诊断标准 $$ f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if } n\text{ is even} \ 3n+1, &amp; \text{if } n\text{ is odd} \end{cases} $$
麦克斯韦方程组 $$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \ \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \ \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \ \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
这些方程式很狭窄。我们可以使用(例如)添加垂直间距 [1em] 在每个换行符(\)之后。正如你在这里看到的：
$$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \[1em] \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \[0.5em] \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \[1em] \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
统计学 固定词组：
$$ \frac{n!}{k!(n-k)!} = {^n}C_k {n \choose k} $$
分数在分数 $$ \frac{\frac{1}{x}+\frac{1}{y}}{y-z} $$
ｎ次方根 $$ \sqrt[n]{1+x+x^2+x^3+\ldots} $$
矩阵 $$ \begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13}\ a_{21} &amp; a_{22} &amp; a_{23}\ a_{31} &amp; a_{32} &amp; a_{33} \end{pmatrix} \begin{bmatrix} 0 &amp; \cdots &amp; 0 \ \vdots &amp; \ddots &amp; \vdots \ 0 &amp; \cdots &amp; 0 \end{bmatrix} $$
标点符号 $$ f(x) = \sqrt{1+x} \quad (x \ge -1) f(x) \sim x^2 \quad (x\to\infty) $$
现在用标点符号:
$$ f(x) = \sqrt{1+x}, \quad x \ge -1 f(x) \sim x^2, \quad x\to\infty $$</content></entry><entry><title>支持Emoji表情符号</title><url>https://yeplain.xyz/post/zh-emoji-support/</url><categories/><tags/><content type="html"> Emoji 表情符号可以通过多种方式在 Hugo 项目中启用。
使用 Emoji 表情符号可以在模板中可以直接调用 emojify
函数或是通过 内联短代码
来实现。
如果要全局启用 Emoji 表情符号，请在网站配置
文件中将 enableEmoji 参数值设置为 true，然后可以直接在内容文件中输入表情符号简写代码，参考如下：
猴子表情 🙈 :see_no_evil:
🙉 :hear_no_evil:
🙊 :speak_no_evil:
数字符号 1️⃣ :one:
2️⃣ :two:
3️⃣ :three:
建筑物 🏡 :house_with_garden:
🏣 :post_office:
🏥 :hospital:
更多的 Emoji 表情符号代码可参考Emoji 配对目录
。
注意: 以上步骤在 Hugo 中启用 Unicode 标准表情符号和序列，但是这些符号的呈现取决于浏览器和平台，要设置表情符号的样式，您可以使用第三方表情符号字体或字体。例如：
.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }</content></entry><entry><title>关于我</title><url>https://yeplain.xyz/about.html</url><categories/><tags/><content type="html"> 编辑中·······</content></entry><entry><title/><url>https://yeplain.xyz/post/prometheus/</url><categories/><tags/><content type="html"/></entry></search>